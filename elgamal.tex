\section{A Hybrid Cryptosystem using ElGamal Encryption and AES}

\label{sec:elgamal} 

In this section, we will proceed to describe a clever but efficient public key encryption scheme, most prominently used in hybrid encryption, called \textit{ElGamal encryption} \cite{Elgamal_1985}. 
However, before diving into the details of the scheme, we provide a brief overview of necessary definitions and theorems in group theory.

\subsection{An overview of Group theory}

\cite{koocmsc} defines an Abelian group $ \G $ as

\begin{definition}
An Abelian group $ \G $ is a finite set of elements along with an operation $ * $ such that:

\begin{itemize}
    \item \textbf{Closure} For all $ a, b \in \G $ we have $ a * b \in \G $. We use $ a * b $ as $ ab $ henceforth for brevity.
    \item \textbf{Associativity} $ \forall a, b, c \in \G $, $ (ab)c = a(bc) $.
    \item \textbf{Commutativity} $ \forall a, b \in \G $, $ ab = ba $.
    \item \textbf{Existence of identity} $ \exists $ an element $ 1 \in \G $ such that $ 1 * a = a $ $ \forall a \in \G $. This element is the identity of $ \G $.
    \item \textbf{Inverse} $ \forall a \in \G$, $ \exists $ an element $ a^{-1} \in \G $ such that $ aa^{-1} = 1 $.
\end{itemize}
\end{definition}

\begin{theorem}
Let $\G$ be a finite Abelian group of order $ q $. Then $ a^q = 1 $ for all a $\in \G$.
\end{theorem}

\begin{proof}

Taken from \cite{koocmsc}.

Let us take $ a_1, \ldots a_q $ to be the elements of $\G$ and let $ a \in \G $ be some arbitrary element. We note that the sequence of elements $ aa_1, aa_2, \ldots , aa_q $ also contains exactly the elements of group $ \G $. Therefore:

\begin{equation*}
\begin{split}
a_1 \cdot a_2 \cdot \cdot \cdot a_q
&= (aa_1) \cdot (aa_2) \cdot \cdot \cdot (aa_q)\\
&= a^q (a_1 \cdot a_2 \cdot \cdot \cdot a_q)
\end{split}
\end{equation*}

On multiplying both sides by $ (a_1 \cdot \cdot \cdot a_q)^{-1} $, we get 

\begin{equation*}
a^q = 1
\end{equation*}
\end{proof}

\begin{corollary}
Let $ \G $ be a finite Abelian group of order $ q $, and let $ n $ be a positive integer.
Then $ g^n = g^{n \mod q} $.
\end{corollary}

\begin{proof}

Taken from \cite{koocmsc}.

Let us write $ n = n_q \mod q $ so that $ n $ can be further written as $ n = aq + n_q $ for some $ a \in \mathbb{Z} $. Then, we have

\begin{equation*}
g^n = g^{aq+n_q} = (g^a)^q g^{n_q} = g^{n_q}
\end{equation*}
\end{proof}

\begin{lemma}
If $ \G $ is an Abelian group with prime order $ q $, then 
\begin{enumerate}
    \item $ \G $ is cyclic; furthermore,
    \item every element of $ \G $ (except the identity) is a generator.
\end{enumerate}
\end{lemma}

\subsection{Discrete Logarithm Problem}

The problem can be described as follows: given a generator $ g $ of group $ \G $ and a random element $ h \in \G $, compute $ \log_g h $.

A common reference is made to the \textit{discrete logarithm assumption}, which says that for most groups, the discrete logarithm problem is ``hard".

\subsection{Overview of Diffie-Hellman Key Agreement}

\label{subsec:dhka} 

The \emph{Diffie-Hellman Key Agreement} (DHKA) provides a very practical solution to the key distribution problem, i.e. it enables two parties, Alice and Bob to agree on a common key over an insecure public channel prior to the actual communication.

The key idea behind the scheme is that in the group \( \mathbb{Z}^*_p \) where \( p \) is a prime, exponentiation is a one-way function and is commutative \cite{paar2009understanding}, i.e.

\begin{equation}
    k = (g^x)^y \equiv (g^y)^x \mod p
\end{equation}

The value \( (g^y)^x \mod p \) is the joint secret key that the parties, Alice and Bob can use to securely communicate in a session.

Let us consider two parties, Alice and Bob who wish to communicate securely and would like to establish a secret key for the same. 
There are certain parameters laid out in the public, either by a trusted third party or by Alice and Bob themselves. 
The DHKA consists of basically two steps, setup and exchange, where a common secret key is agreed upon.

The setup protocol is as follows:

\begin{tcolorbox}
\textbf{Setup} 

\begin{enumerate}
    \item Choose a large prime number \( p \).
    \item Choose an integer \( g \in \{2, 3, \ldots , p-2\} \). (Technically, this is a generator of group \( \mathbb{Z}^*_p \))
    \item Release \( p \) and \( g \) publicly.
\end{enumerate}
\end{tcolorbox}

Alice and Bob agree publicly on prime \( p \) and generator \( g \in \mathbb{Z}^*_p \). 
Let \( n = |\mathbb{Z}^*_p| \).

The exchange protocol then follows as:

\begin{tcolorbox}
\textbf{Exchange} 
\begin{enumerate}
    \item Alice chooses \( a \leftarrow \mathbb{Z}_n \). 
    \item Bob chooses \( b \leftarrow \mathbb{Z}_n \).
    \item Alice computes \( A = g^a \mod p \) and sends it to Bob.
    \item Bob computes \( B = g^b \mod p \) and sends it to Alice.
    \item Bob privately computes \( k_1 := A^b \mod p \). Similarly, Alice privately computes \( k_2 := B^a \).
\end{enumerate}
\end{tcolorbox}

We see that \( k_1 := A^b \mod p = (g^a)^b \mod p \) and \( k_2 := B^a \mod p = (g^b)^a \mod p \). Hence we see that both parties come to agree on a common secret key, namely

\begin{equation}
    k_1 = k_2 = g^{ab} \mod p
\end{equation}

It is to be noted that in the public domain, we have \( p \), \( g \), \( g^a \), \( g^b \). 
From these parameters, it is ``hard" for an attacker to decipher \( k := g^{ab} \), which is the secret key Alice and Bob have agreed upon. 
However, we shall not show this explicitly for the sake of brevity.

\subsection{Elgamal encryption protocol}

We proceed to describe the Elgamal encryption scheme which is based on the DHKA scheme. As usual, let's consider two parties, Alice and Bob.



\smallskip

% After the necessary overview, we go ahead and describe the ElGamal encryption scheme whose security is closely related to the discrete logarithm assumption:

\begin{algorithmic}
\STATE {\textbf{Key generation} \textsc{Gen}($ 1^k $):}
\STATE ($ \G $, $ q $, $ g $) $ \leftarrow \textsc{GroupGen} (1^k) $ 
\STATE Choose $ x \leftarrow \Zq $; set $ y = g^x $ 
\STATE Output $ PK = ( \G, q, g, y) $ and $ SK = x $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Encryption} $ \mathcal{E}_{pk} (m) $ (where $ m \in \G $)}
\STATE Pick $ r \leftarrow \Zq $ 
\STATE Output $ \langle g^r, y^r m \rangle $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Decryption} $ \mathcal{D}_{sk} (A, B) $}:
\STATE Compute $ m = \frac{B}{A^x} $ 
\end{algorithmic}

The correctness of the decryption process follows from,

\begin{equation*}
\frac{y^r m}{(g^r)^x} = \frac{y^r m}{(g^x)^r} = \frac{y^r m }{y^r} = m
\end{equation*}

\subsection{Decisional Diffie-Hellman (DDH) Assumption}

The DHKE protocol is dependent on the cyclic group \( \G \) chosen (along with generator \( g \)).
As seen in sec. \ref{subsec:dhka}, Alice and Bob choose \( a \) and \( b \) respectively, uniform randomly. 
After which, \( g^a \) and \( g^b \) is computed, and the secret key corresponding to this is \( g^{ab} \).

Let us define the two schemes,

\begin{itemize}
    \item Define scheme \( L_1^{\G} \)\footnote{The superscript denotes that the scheme operates in the cyclic group \( \G \).} as follows: 
    \begin{enumerate}
        \item \( a, b \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( (g^a, g^b, g^{ab}) \).
    \end{enumerate}

    \item Define scheme \( L_2^{\G} \) as follows: 
    \begin{enumerate}
        \item \( a, b, c \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( g^a, g^b, g^c \).
    \end{enumerate}
\end{itemize}

As seen, scheme \( L_1^{\G} \) generates a secret key \( g^{ab} \) and scheme \( L_2^{\G} \) generates an independent random key \( g^c \).

The \textit{decisional Diffie-Hellman (DDH) assumption} states that

\begin{equation} \label{eq:ddh} 
    L_1^{\G} \approx L_2^{\G}
\end{equation}

In layman terms, eq. \ref{eq:ddh} means that choosing \( c \) is ``as random as" \( ab \) where \( a \) and \( b \) have been chosen uniform randomly.

\subsection{Security of Elgamal}
