\section{A Hybrid Cryptosystem using ElGamal Encryption and AES}

\label{sec:elgamal} 

In this section, we will proceed to describe a clever but efficient public key encryption scheme, most prominently used in hybrid encryption, called \textit{ElGamal encryption} \cite{Elgamal_1985}. 
However, before diving into the details of the scheme, we would like to point out that some basic prerequisites in group theory and other concepts that are necessary for the reader to understand how ElGamal works are listed in the \textbf{Appendix}.

%omitted parts moved to appendix

\subsection{Overview of Diffie-Hellman Key Agreement}

\label{subsec:dhka} 

The \emph{Diffie-Hellman Key Agreement} (DHKA) provides a very practical solution to the key distribution problem, i.e. it enables two parties, Alice and Bob to agree on a common key over an insecure public channel prior to the actual communication.

The key idea behind the scheme is that in the group \( \mathbb{Z}^*_p \) where \( p \) is a prime, exponentiation is a one-way function and is commutative \cite{paar2009understanding}, i.e.
\begin{equation}
    k = (g^x)^y \equiv (g^y)^x \mod p
\end{equation}

The value \( (g^y)^x \mod p \) is the joint secret key that the parties, Alice and Bob can use to securely communicate in a session.

Let us consider two parties, Alice and Bob who wish to communicate securely and would like to establish a secret key for the same. 
There are certain parameters laid out in the public, either by a trusted third party or by Alice and Bob themselves. 
The DHKA consists of basically two steps, setup and exchange, where a common secret key is agreed upon.

The setup protocol is as follows:

\begin{tcolorbox}
\textbf{Setup} 

\begin{enumerate}
    \item Choose a large prime number \( p \).
    \item Choose an integer \( g \in \{2, 3, \ldots , p-2\} \). (Technically, this is a generator of group \( \mathbb{Z}^*_p \))
    \item Release \( p \) and \( g \) publicly.
\end{enumerate}
\end{tcolorbox}

Alice and Bob agree publicly on prime \( p \) and generator \( g \in \mathbb{Z}^*_p \). 
Let \( n = |\mathbb{Z}^*_p| \).

The exchange protocol then follows as:

\begin{tcolorbox}
\textbf{Exchange} 
\begin{enumerate}
    \item Alice chooses \( a \leftarrow \mathbb{Z}_n \). 
    \item Bob chooses \( b \leftarrow \mathbb{Z}_n \).
    \item Alice computes \( A = g^a \mod p \) and sends it to Bob.
    \item Bob computes \( B = g^b \mod p \) and sends it to Alice.
    \item Bob privately computes \( k_1 := A^b \mod p \). Similarly, Alice privately computes \( k_2 := B^a \).
\end{enumerate}
\end{tcolorbox}

We see that \( k_1 := A^b \mod p = (g^a)^b \mod p \) and \( k_2 := B^a \mod p = (g^b)^a \mod p \). Hence we see that both parties come to agree on a common secret key, namely
\begin{equation}
    k_1 = k_2 = g^{ab} \mod p
\end{equation}

It is to be noted that in the public domain, we have \( p \), \( g \), \( g^a \), \( g^b \). 
From these parameters, it is ``hard" for an attacker to decipher \( k := g^{ab} \mod p\), which is the secret key Alice and Bob have agreed upon. 
However, we shall not show this explicitly for the sake of brevity.

\subsection{Description of the ElGamal Encryption Protocol}

\label{subsec:desc_elgalmal}    

We proceed to describe the ElGamal encryption scheme which is based on the DHKA scheme \cite{Elgamal_1985}. 
As usual, let's consider two parties, Alice and Bob. 
As seen in sec. \ref{subsec:dhka}, Alice and Bob agree on a common secret key \( k_M \) via DHKA.
In the setup phase of the protocol, we require no trusted third party to generate the prime \( p \) and generator \( g \) in group \( \Zp \) , for they can be generated by the receiver, Bob who makes them public, either in a database or on his website \cite{paar2009understanding}.

The ElGamal protocol consists of 3 steps, i.e key generation \textsc{Gen}(\( 1^l \)), encryption \textsc), encryption \( \mathcal{E}_{pk}\)(\( m \)) and decryption \( \mathcal{D}_{sk} \)(\( \beta, B \)) as described below:

\smallskip

% After the necessary overview, we go ahead and describe the ElGamal encryption scheme whose security is closely related to the discrete logarithm assumption:

\begin{algorithmic}
\STATE {\textbf{Key generation} \textsc{Gen}($ 1^l $):}
\STATE ($ \G $, $ p $, $ g $) $ \leftarrow \textsc{GroupGen} (1^l) $ 
\STATE Choose $ a \leftarrow \Zp $; set $ \alpha = g^a \mod p $ 
\STATE Output $ pk = ( \G, p, g, \alpha) $ and $ sk = a $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Encryption} $ \mathcal{E}_{pk} (m) $ (where $ m \in \G $)}
\STATE Pick $ b \leftarrow \Zp $; set \( \beta = g^b \mod p \)  
\STATE Output $ ( \beta, m \cdot \alpha^b \mod p ) $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Decryption} $ \mathcal{D}_{sk} (\beta, y \equiv m \cdot \alpha^b \mod p) $}:
\STATE Compute $ m = y/\beta^a $ 
\end{algorithmic}

The correctness of the decryption process follows from,

\begin{equation*}
\frac{m \cdot \alpha^b}{(g^b)^a} = \frac{m \cdot \alpha^b}{(g^a)^b} = \frac{m \cdot \alpha^b}{\alpha^b} = m
\end{equation*}

To reiterate the above algorithm, Bob computes his private key \( b \leftarrow \Zp \) and public key \( \beta \equiv g^b \mod p \).
Note that this key pair remains constant throughout the communication session.
However, Alice will have to generate a new public-private key pair everytime she wishes to send a message.
\( a \leftarrow \Zp \) and \( \alpha = g^a \mod p \) are her private and public keys respectively.
Note that \( \alpha \) is a temporary key.
The joint shared secret key is then computed by both parties as \( k_M \) used to mask the plaintext message \cite{paar2009understanding}.

During the actual encryption process, Alice multiplies the plaintext message \( m \) with the shared secret key (\textit{a.k.a.} masking key).
On the decryption side, Bob simply reverses the encryption by multiplying the ciphertext with the inverse of the masking key.

\subsection{Decisional Diffie-Hellman (DDH) Assumption}

The DHKE protocol is dependent on the cyclic group \( \G \) chosen (along with generator \( g \)).
As seen in sec. \ref{subsec:dhka}, Alice and Bob choose \( a \) and \( b \) respectively, uniform randomly. 
After which, \( g^a \) and \( g^b \) is computed, and the secret key corresponding to this is \( g^{ab} \).

Let us define the two schemes,

\begin{itemize}
    \item Define scheme \( L_1^{\G} \)\footnote{The superscript denotes that the scheme operates in the cyclic group \( \G \).} as follows: 
    \begin{enumerate}
        \item \( a, b \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( (g^a, g^b, g^{ab}) \).
    \end{enumerate}

    \item Define scheme \( L_2^{\G} \) as follows: 
    \begin{enumerate}
        \item \( a, b, c \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( g^a, g^b, g^c \).
    \end{enumerate}
\end{itemize}

As seen, scheme \( L_1^{\G} \) generates a secret key \( g^{ab} \) and scheme \( L_2^{\G} \) generates an independent random key \( g^c \).

The \textit{decisional Diffie-Hellman (DDH) assumption} states that

\begin{equation} \label{eq:ddh} 
    L_1^{\G} \approx L_2^{\G}
\end{equation}

In layman terms, eq. \ref{eq:ddh} means that choosing \( c \) is ``as random as" \( ab \) where \( a \) and \( b \) have been chosen uniform randomly.

\subsection{Security of Elgamal}

When dealing with the security of the scheme, we need to distinguish between two types of attacks, i.e. passive (listen-only) and active attacks (where the adversary Charlie can generate and alter messages between the two main parties of communication).

\subsubsection{Passive attacks}

In the public channel, we have \( p \), \( g \), \( k_a \equiv g^a \), \( k_b \equiv g^b \) and ciphertext \( y \) . A passive attack would mean recovering message \( x \) from the encrypted ciphertext \( y = x \cdot g^{ab} \)\textsuperscript{   }\footnote{Technically, it is \( y = x \cdot g^{ab} \mod p \) but we omit \( \mod p \) for the sake of brevity.} via eavesdropping.
Security against this form of attack depends on the hardness of DHKE. 
This has no known\footnote{This is subject to change.} methods other than computing the discrete logarithm problem.
Let assume that our adversary Charlie is powerful enough to compute these logarithms, then there are two ways he could go about it:

\begin{itemize}
    \item By finding Bob's secret key \( b \) and recovering message \( x \):
        \begin{equation}
            b = \log_g k_b \mod p
        \end{equation}

        All this is assuming that Charlie can compute discrete logarithms, which is practically not feasible. 
        If the adversary succeeds in doing so, then he follows the same steps as Bob to recover x, i.e.

        \begin{equation}
            x \equiv y \cdot (k_a^b)^{-1} \mod p
        \end{equation}
        
    \item Another way would be for Charlie to recover Alice's secret exponent \( a \):
        \begin{equation}
            a = \log_g k_a \mod p
        \end{equation}
        
        We make the same assumption as before i.e. Charlie has the power to compute this discrete logarithm problem.
        He then similarly, proceeds to compute the plaintext:

        \begin{equation}
            x \equiv y \cdot (k_b^a)^{-1} \mod p     
        \end{equation}
\end{itemize}

\subsubsection{Active attacks}

The ElGamal encryption protocol is an asymmetric scheme and as such, it must be ensured that the public keys are indeed authentic i.e. Alice (the sender) indeed has the public key that belongs to Bob.
If an adversary Charlie convinces Alice otherwise that his key is indeed Bob's, then the communication channel is compromised and Charlie can then attack the scheme. 
This is a \textit{man-in-the-middle} attack.
Preventing this type of attack requires authentication of the key via certificates\footnote{We shall not discuss this for the sake of brevity.}.

Another breach of the protocol can happen when the private key \( a \) of Alice is used more than once.
As mentioned earlier\footnote{See section \ref{subsec:desc_elgamal}}, Alice generates her public-private key pair for every message.
Let us assume a case scenario where Alice uses the same private key \( a \) to encrypt two subsequent messages, \( m_1 \) and \( m_2 \).
In both the cases, the shared masking key \( k_M \equiv \beta^a \mod p\) will be the same.
Also note that for both the messages, Alice's public key \( \alpha \) would be identical.
She then sends the corresponding ciphertexts for both the messages as \( y_1 = m_1 \cdot k_M \mod p \) and \( y_2 = m_2 \cdot k_M \mod p \) respectively, along with her public key in the form of tuples i.e.

\begin{equation*}
    (y_1, \alpha) \quad \& \quad (y_2, \alpha)
\end{equation*}

If somehow the adversary, Charlie can guess one of the messages, say \( m_1 \), he can then compute the shared secret key via the operation:

\begin{equation*}
    k_M \equiv y_1 m_1^{-1} \mod p
\end{equation*}

And can subsequently decipher the second message \( m_2 \) via

\begin{equation*}
    m_2 \equiv y_2 k_M^{-1} \mod p
\end{equation*}

Note that for any message encrypted using the same private key \( a \), Charlie can recover the message, provided he can guess one of the many messages encrypted with this private key \( a \).

Also note that Charlie can detect the reuse of the private key simply because it leads to the same temporary public key \( \alpha \) \cite{paar2009understanding}.

\subsection{AES - A Symmetric Key Cryptosystem}

Originally named the Rijndael algorithm after its creators, Vincent Rijmen and Joan Daemen, AES is a widely used block cipher and ergo uses a symmetric key, with a block size of 128 bits but with varying key sizes of 128, 192, and 256 bits.

We shall not be going into a lot of detail about AES but we shall provide a very brief introduction to the same before we club it with ElGamal to produce a hybrid encryption scheme.

AES is based on a design principle called a substitution-permutation network, and is implemented in several rounds/iterations, which in turn depend on the key size as follows,

\begin{align*}
    \text{Number of rounds}=\begin{cases}
    10 \text{ if key size$ = 128$ bits,}\\
    12 \text{ if key size$ = 192$ bits,}\\
    14 \text{ if key size$ = 256$ bits.}
    \end{cases}
\end{align*}

It is worth noting that AES takes each the data in each block and treats it bytewise, not bitwise, to put it loosely, so, say, a 128 bit block of plaintext can be seen as being 16 bytes long, and it can be represented as a two dimensional array, called a state, of dimensions $4\times4$.

There exists a specified and fixed lookup table called the S-box given in the design which is used to substitute bytes of the plaintext block, which are represented by a two dimensional array as mentioned earlier, in each round.

Now we shall give a very brief description of what goes down in each round of an implementation of AES, without getting too much into the mathematics or details of it as it will involve quite a bit of field theory and the like, and interested readers may take a look at \cite{daemen1999aes} for a detailed and well guided explanation of what AES does.

%\begin{tcolorbox}
\emph{Key Expansion}: AES uses something called a key schedule (whose details have been omitted for the sake of brevity) to expand the given cipher key into a desired number of round keys, with the round key length being equal to the block length, for every round of transformation.

\begin{center}
    \textbf{AES Round}
\end{center}

\begin{enumerate}
    \setlength\itemsep{1em}
    \item \emph{Initial Round Key Addition}: The round key is added to each byte of the initial state by bitwise XOR;
    \item \emph{ByteSub}: The bytes in the input block are substituted by the means of the S-box (each byte is replaced by a byte obtained by the means of an $8$-bit substitution box) given in the design to produce a $4\times 4$ two (major order) dimensional array/state, the mathematics of which we will not go into, and this substitution introduces non-linearity into the cipher and this step is invertible for the sake of decryption;
    \item \emph{ShiftRow}: Then the rows of the state are shifted as follows

    \begin{enumerate}
        \item The first row remains untouched;
        \item The $i^\text{th}$ row is shifted to the left by $i-1$ positions/bytes, and any bytes that spill over, so to speak, are circled back around and added to the right side of said row;
    \end{enumerate}

    This step is clearly and easily invertible;
\item \emph{MixColumn}: In every round but the last round, every column is treated as a polynomial with coefficients in the finite field of size $2^8$ and is multiplied modulo $x^4+1$ with a fixed polynomial (that is chosen in such a way that it is coprime to $x^4+1$ and therefore has an inverse which will be handy during decryption) to produce another polynomial which corresponds to another column which replaces the original column; 
    in short the bytes of each column are run through an invertible linear transformation in this step to get a new column;
\item \emph{Round Key Addition}: The next round key is added and this process is iterated, and in the last round, the \emph{MixColumn} step shall be omitted.
\end{enumerate}

In short, the ability to invert each step given the knowledge of the symmetric key involved will allow decryption of the ciphertext produced using AES.

Note that due to the size of the key in AES, whether 256 bits or 128 towards the lower end (therefore giving us either $2^{128}, 2^{192},$ or $2^{256}$ many possible keys), brute forcing AES is close to impossible using currently available computational power, although other attacks have been discovered that compromised flawed implementations of AES and/or for lesser number of rounds of AES, so they are not considered to be of much concern in a practical sense at the moment.

Now that we have introduced a suitable pair of symmetric key and asymmetric key cryptosystems, we can go on and describe the construction of a hybrid encryption scheme using the same.
%\end{tcolorbox}

\subsection{A Hybrid Encryption Scheme Based on ElGamal and AES}

Now that we have sufficiently described the schemes required for the purposes of this paper, they can now be incorporated into a hybrid encryption scheme. 
This process is quite straightforward.

\begin{enumerate}
    \setlength\itemsep{1em}
    \item First, keys are generated for ElGamal and AES, by the recipient and the sender respectively;
    \item\emph{KEM}: Then the symmetric key for AES  is encrypted using the ElGamal public key of the intended recipient to obtain the ciphertext $C=(A,B)$\textsuperscript{   }\footnote{Refer to the section on the description of the ElGamal encryption protocol for an explanation about the contents of the tuple $C$.};
    \item\emph{DEM}: Then the message plaintext is encrypted using AES with the key the sender generated earlier to get the ciphertext $C'$;
    \item The message gets sent to the recipient, who can then apply ElGamal and AES decryption algorithms, in that order, to first decrypt $C$ using their secret ElGamal key to get the symmetric key for AES then use that to decrypt $C'$ to get the plaintext of the message.
\end{enumerate}

With this, we end up with a hybrid encryption scheme that combines ElGamal and AES and thus shares in both their security advantages.\footnote{One can refer to \cite{Iavich_Gnatyuk_Jintcharadze_Polishchuk_Odarchenko_2018} for a look at a ElGamal+AES based encryption scheme described by Iavich et al.}
