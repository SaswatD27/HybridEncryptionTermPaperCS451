\section{A Hybrid Cryptosystem using ElGamal Encryption and AES}

\label{sec:elgamal} 

In this section, we will proceed to describe a clever but efficient public key encryption scheme, most prominently used in hybrid encryption, called \textit{ElGamal encryption} \cite{Elgamal_1985}. 
However, before diving into the details of the scheme, we provide a brief overview of necessary definitions and theorems in group theory.

\subsection{An overview of Group theory}

\cite{koocmsc} defines an Abelian group $ \G $ as

\begin{definition}
An Abelian group $ \G $ is a finite set of elements along with an operation $ * $ such that:

\begin{itemize}
    \item \textbf{Closure} For all $ a, b \in \G $ we have $ a * b \in \G $. We use $ a * b $ as $ ab $ henceforth for brevity.
    \item \textbf{Associativity} $ \forall a, b, c \in \G $, $ (ab)c = a(bc) $.
    \item \textbf{Commutativity} $ \forall a, b \in \G $, $ ab = ba $.
    \item \textbf{Existence of identity} $ \exists $ an element $ 1 \in \G $ such that $ 1 * a = a $ $ \forall a \in \G $. This element is the identity of $ \G $.
    \item \textbf{Inverse} $ \forall a \in \G$, $ \exists $ an element $ a^{-1} \in \G $ such that $ aa^{-1} = 1 $.
\end{itemize}
\end{definition}

\begin{theorem}
Let $\G$ be a finite Abelian group of order $ q $. Then $ a^q = 1 $ for all a $\in \G$.
\end{theorem}

\begin{proof}

Taken from \cite{koocmsc}.

Let us take $ a_1, \ldots a_q $ to be the elements of $\G$ and let $ a \in \G $ be some arbitrary element. We note that the sequence of elements $ aa_1, aa_2, \ldots , aa_q $ also contains exactly the elements of group $ \G $. Therefore:
\begin{equation*}
\begin{split}
a_1 \cdot a_2 \cdot \cdot \cdot a_q
&= (aa_1) \cdot (aa_2) \cdot \cdot \cdot (aa_q)\\
&= a^q (a_1 \cdot a_2 \cdot \cdot \cdot a_q)
\end{split}
\end{equation*}

On multiplying both sides by $ (a_1 \cdot \cdot \cdot a_q)^{-1} $, we get 
\begin{equation*}
a^q = 1
\end{equation*}
\end{proof}

\begin{corollary}
Let $ \G $ be a finite Abelian group of order $ q $, and let $ n $ be a positive integer.
Then $ g^n = g^{n \mod q} $.
\end{corollary}

\begin{proof}

Taken from \cite{koocmsc}.

Let us write $ n = n_q \mod q $ so that $ n $ can be further written as $ n = aq + n_q $ for some $ a \in \mathbb{Z} $. Then, we have
\begin{equation*}
g^n = g^{aq+n_q} = (g^a)^q g^{n_q} = g^{n_q}
\end{equation*}
\end{proof}

\begin{lemma}
If $ \G $ is an Abelian group with prime order $ q $, then 
\begin{enumerate}
    \item $ \G $ is cyclic; furthermore,
    \item every element of $ \G $ (except the identity) is a generator.
\end{enumerate}
\end{lemma}

\subsection{Discrete Logarithm Problem}
The problem can be described as follows: given a generator $ g $ of group $ \G $ and a random element $ h \in \G $, compute $ \log_g h $.

A common reference is made to the \textit{discrete logarithm assumption}, which says that for most groups, the discrete logarithm problem is ``hard".

\subsection{Overview of Diffie-Hellman Key Agreement}

\label{subsec:dhka} 

The \emph{Diffie-Hellman Key Agreement} (DHKA) provides a very practical solution to the key distribution problem, i.e. it enables two parties, Alice and Bob to agree on a common key over an insecure public channel prior to the actual communication.

The key idea behind the scheme is that in the group \( \mathbb{Z}^*_p \) where \( p \) is a prime, exponentiation is a one-way function and is commutative \cite{paar2009understanding}, i.e.
\begin{equation}
    k = (g^x)^y \equiv (g^y)^x \mod p
\end{equation}

The value \( (g^y)^x \mod p \) is the joint secret key that the parties, Alice and Bob can use to securely communicate in a session.

Let us consider two parties, Alice and Bob who wish to communicate securely and would like to establish a secret key for the same. 
There are certain parameters laid out in the public, either by a trusted third party or by Alice and Bob themselves. 
The DHKA consists of basically two steps, setup and exchange, where a common secret key is agreed upon.

The setup protocol is as follows:

\begin{tcolorbox}
\textbf{Setup} 

\begin{enumerate}
    \item Choose a large prime number \( p \).
    \item Choose an integer \( g \in \{2, 3, \ldots , p-2\} \). (Technically, this is a generator of group \( \mathbb{Z}^*_p \))
    \item Release \( p \) and \( g \) publicly.
\end{enumerate}
\end{tcolorbox}

Alice and Bob agree publicly on prime \( p \) and generator \( g \in \mathbb{Z}^*_p \). 
Let \( n = |\mathbb{Z}^*_p| \).

The exchange protocol then follows as:

\begin{tcolorbox}
\textbf{Exchange} 
\begin{enumerate}
    \item Alice chooses \( a \leftarrow \mathbb{Z}_n \). 
    \item Bob chooses \( b \leftarrow \mathbb{Z}_n \).
    \item Alice computes \( A = g^a \mod p \) and sends it to Bob.
    \item Bob computes \( B = g^b \mod p \) and sends it to Alice.
    \item Bob privately computes \( k_1 := A^b \mod p \). Similarly, Alice privately computes \( k_2 := B^a \).
\end{enumerate}
\end{tcolorbox}

We see that \( k_1 := A^b \mod p = (g^a)^b \mod p \) and \( k_2 := B^a \mod p = (g^b)^a \mod p \). Hence we see that both parties come to agree on a common secret key, namely
\begin{equation}
    k_1 = k_2 = g^{ab} \mod p
\end{equation}

It is to be noted that in the public domain, we have \( p \), \( g \), \( g^a \), \( g^b \). 
From these parameters, it is ``hard" for an attacker to decipher \( k := g^{ab} \mod p\), which is the secret key Alice and Bob have agreed upon. 
However, we shall not show this explicitly for the sake of brevity.

\subsection{Description of the ElGamal Encryption Protocol}

We proceed to describe the ElGamal encryption scheme which is based on the DHKA scheme. As usual, let's consider two parties, Alice and Bob. 
As seen in sec. \ref{subsec:dhka}, Alice and Bob agree on a common secret key \( k_m \) via DHKA. 




\smallskip

% After the necessary overview, we go ahead and describe the ElGamal encryption scheme whose security is closely related to the discrete logarithm assumption:

\begin{algorithmic}
\STATE {\textbf{Key generation} \textsc{Gen}($ 1^k $):}
\STATE ($ \G $, $ q $, $ g $) $ \leftarrow \textsc{GroupGen} (1^k) $ 
\STATE Choose $ x \leftarrow \Zq $; set $ y = g^x $ 
\STATE Output $ PK = ( \G, q, g, y) $ and $ SK = x $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Encryption} $ \mathcal{E}_{pk} (m) $ (where $ m \in \G $)}
\STATE Pick $ r \leftarrow \Zq $ 
\STATE Output $ \langle g^r, y^r m \rangle $ 
\end{algorithmic} 

\smallskip

\begin{algorithmic}
\STATE {\textbf{Decryption} $ \mathcal{D}_{sk} (A, B) $}:
\STATE Compute $ m = \frac{B}{A^x} $ 
\end{algorithmic}

The correctness of the decryption process follows from,

\begin{equation*}
\frac{y^r m}{(g^r)^x} = \frac{y^r m}{(g^x)^r} = \frac{y^r m }{y^r} = m
\end{equation*}

\subsection{Decisional Diffie-Hellman (DDH) Assumption}

The DHKE protocol is dependent on the cyclic group \( \G \) chosen (along with generator \( g \)).
As seen in sec. \ref{subsec:dhka}, Alice and Bob choose \( a \) and \( b \) respectively, uniform randomly. 
After which, \( g^a \) and \( g^b \) is computed, and the secret key corresponding to this is \( g^{ab} \).

Let us define the two schemes,

\begin{itemize}
    \item Define scheme \( L_1^{\G} \)\footnote{The superscript denotes that the scheme operates in the cyclic group \( \G \).} as follows: 
    \begin{enumerate}
        \item \( a, b \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( (g^a, g^b, g^{ab}) \).
    \end{enumerate}

    \item Define scheme \( L_2^{\G} \) as follows: 
    \begin{enumerate}
        \item \( a, b, c \leftarrow \mathbb{Z}_n \).
        \item Return tuple \( g^a, g^b, g^c \).
    \end{enumerate}
\end{itemize}

As seen, scheme \( L_1^{\G} \) generates a secret key \( g^{ab} \) and scheme \( L_2^{\G} \) generates an independent random key \( g^c \).

The \textit{decisional Diffie-Hellman (DDH) assumption} states that

\begin{equation} \label{eq:ddh} 
    L_1^{\G} \approx L_2^{\G}
\end{equation}

In layman terms, eq. \ref{eq:ddh} means that choosing \( c \) is ``as random as" \( ab \) where \( a \) and \( b \) have been chosen uniform randomly.

\subsection{Security of Elgamal}

When dealing with the security of the scheme, we need to distinguish between two types of attacks, i.e. passive (listen-only) and active attacks (where the adversary Charlie can generate and alter messages between the two main parties of communication).

\subsubsection{Passive attacks}

In the public channel, we have \( p \), \( g \), \( k_a \equiv g^a \), \( k_b \equiv g^b \) and cyphertext \( y \) . A passive attack would mean recovering message \( x \) from the encrypted cyphertext \( y = x \cdot g^{ab} \)\footnote{Technically, it is \( y = x \cdot g^{ab} \mod p \) but we omit \( \mod p \) for the sake of brevity.} via eavesdropping.
Security against this form of attack depends on the hardness of DHKE. 
This has no known\footnote{This is subject to change.} methods other than computing the discrete logarithm problem.
Let assume that our adversary Charlie is powerful enough to compute these logarithms, then there are two ways he could go about it:

\begin{itemize}
    \item By finding Bob's secret key \( b \) and recovering message \( x \):
        \begin{equation}
            b = \log_g k_b \mod p
        \end{equation}

        All this is assuming that Charlie can compute discrete logarithms, which is practically not feasible. 
        If the adversary succeeds in doing so, then he follows the same steps as Bob to recover x, i.e.

        \begin{equation}
            x \equiv y \cdot (k_a^b)^{-1} \mod p
        \end{equation}
        
    \item Another way would be for Charlie to recover Alice's secret exponent \( a \):
        \begin{equation}
            a = \log_g k_a \mod p
        \end{equation}
        
        We make the same assumption as before i.e. Charlie has the power to compute this discrete logarithm problem.
        He then similarly, proceeds to compute the plaintext:

        \begin{equation}
            x \equiv y \cdot (k_b^a)^{-1} \mod p     
        \end{equation}
\end{itemize}

\subsubsection{Active attacks}

The ElGamal encryption protocol is an asymmetric scheme and as such, it must be ensured that the public keys are indeed authentic i.e. Alice (the sender) indeed has the public key that belongs to Bob.
If an adversary Charlie convinces Alice otherwise that his key is indeed Bob's, then the communication channel is compromised and Charlie can then attack the scheme.
Preventing this type of attack requires authentication of the key via certificates\footnote{We shall not discuss this for the sake of brevity.}.

Another point for breaching the protocol is that the sending party's secret exponent \( a \) must not be reused.
